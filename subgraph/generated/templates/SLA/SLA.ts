// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class DTokensCreated extends ethereum.Event {
  get params(): DTokensCreated__Params {
    return new DTokensCreated__Params(this);
  }
}

export class DTokensCreated__Params {
  _event: DTokensCreated;

  constructor(event: DTokensCreated) {
    this._event = event;
  }

  get tokenAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get dpTokenAddress(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get dpTokenName(): string {
    return this._event.parameters[2].value.toString();
  }

  get dpTokenSymbol(): string {
    return this._event.parameters[3].value.toString();
  }

  get duTokenAddress(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get duTokenName(): string {
    return this._event.parameters[5].value.toString();
  }

  get duTokenSymbol(): string {
    return this._event.parameters[6].value.toString();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class ProviderRewardGenerated extends ethereum.Event {
  get params(): ProviderRewardGenerated__Params {
    return new ProviderRewardGenerated__Params(this);
  }
}

export class ProviderRewardGenerated__Params {
  _event: ProviderRewardGenerated;

  constructor(event: ProviderRewardGenerated) {
    this._event = event;
  }

  get periodId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get tokenAddress(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get rewardPercentage(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get rewardPercentagePrecision(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get rewardAmount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class ProviderWithdraw extends ethereum.Event {
  get params(): ProviderWithdraw__Params {
    return new ProviderWithdraw__Params(this);
  }
}

export class ProviderWithdraw__Params {
  _event: ProviderWithdraw;

  constructor(event: ProviderWithdraw) {
    this._event = event;
  }

  get tokenAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get periodId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get caller(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class SLICreated extends ethereum.Event {
  get params(): SLICreated__Params {
    return new SLICreated__Params(this);
  }
}

export class SLICreated__Params {
  _event: SLICreated;

  constructor(event: SLICreated) {
    this._event = event;
  }

  get timestamp(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get sli(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get periodId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Stake extends ethereum.Event {
  get params(): Stake__Params {
    return new Stake__Params(this);
  }
}

export class Stake__Params {
  _event: Stake;

  constructor(event: Stake) {
    this._event = event;
  }

  get tokenAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get periodId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get caller(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class UserCompensationGenerated extends ethereum.Event {
  get params(): UserCompensationGenerated__Params {
    return new UserCompensationGenerated__Params(this);
  }
}

export class UserCompensationGenerated__Params {
  _event: UserCompensationGenerated;

  constructor(event: UserCompensationGenerated) {
    this._event = event;
  }

  get periodId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get tokenAddress(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get usersStake(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get leverage(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get compensation(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class UserWithdraw extends ethereum.Event {
  get params(): UserWithdraw__Params {
    return new UserWithdraw__Params(this);
  }
}

export class UserWithdraw__Params {
  _event: UserWithdraw;

  constructor(event: UserWithdraw) {
    this._event = event;
  }

  get tokenAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get periodId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get caller(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class SLA__getTokenStakeResult {
  value0: Address;
  value1: BigInt;

  constructor(value0: Address, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class SLA__periodSLIsResult {
  value0: BigInt;
  value1: BigInt;
  value2: i32;

  constructor(value0: BigInt, value1: BigInt, value2: i32) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set(
      "value2",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value2))
    );
    return map;
  }
}

export class SLA extends ethereum.SmartContract {
  static bind(address: Address): SLA {
    return new SLA("SLA", address);
  }

  DSLAburnRate(): BigInt {
    let result = super.call("DSLAburnRate", "DSLAburnRate():(uint256)", []);

    return result[0].toBigInt();
  }

  try_DSLAburnRate(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("DSLAburnRate", "DSLAburnRate():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  allowedTokens(param0: BigInt): Address {
    let result = super.call(
      "allowedTokens",
      "allowedTokens(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toAddress();
  }

  try_allowedTokens(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "allowedTokens",
      "allowedTokens(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  breachedContract(): boolean {
    let result = super.call(
      "breachedContract",
      "breachedContract():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_breachedContract(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "breachedContract",
      "breachedContract():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  contractFinished(): boolean {
    let result = super.call(
      "contractFinished",
      "contractFinished():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_contractFinished(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "contractFinished",
      "contractFinished():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  creationBlockNumber(): BigInt {
    let result = super.call(
      "creationBlockNumber",
      "creationBlockNumber():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_creationBlockNumber(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "creationBlockNumber",
      "creationBlockNumber():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  dpTokenRegistry(param0: Address): Address {
    let result = super.call(
      "dpTokenRegistry",
      "dpTokenRegistry(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toAddress();
  }

  try_dpTokenRegistry(param0: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "dpTokenRegistry",
      "dpTokenRegistry(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  duTokenRegistry(param0: Address): Address {
    let result = super.call(
      "duTokenRegistry",
      "duTokenRegistry(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toAddress();
  }

  try_duTokenRegistry(param0: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "duTokenRegistry",
      "duTokenRegistry(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  extraData(param0: BigInt): Bytes {
    let result = super.call("extraData", "extraData(uint256):(bytes32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toBytes();
  }

  try_extraData(param0: BigInt): ethereum.CallResult<Bytes> {
    let result = super.tryCall("extraData", "extraData(uint256):(bytes32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  finalPeriodId(): BigInt {
    let result = super.call("finalPeriodId", "finalPeriodId():(uint128)", []);

    return result[0].toBigInt();
  }

  try_finalPeriodId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "finalPeriodId",
      "finalPeriodId():(uint128)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getAllowedTokensLength(): BigInt {
    let result = super.call(
      "getAllowedTokensLength",
      "getAllowedTokensLength():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getAllowedTokensLength(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getAllowedTokensLength",
      "getAllowedTokensLength():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getStakersLength(): BigInt {
    let result = super.call(
      "getStakersLength",
      "getStakersLength():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getStakersLength(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getStakersLength",
      "getStakersLength():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTokenStake(
    _staker: Address,
    _allowedTokenIndex: BigInt
  ): SLA__getTokenStakeResult {
    let result = super.call(
      "getTokenStake",
      "getTokenStake(address,uint256):(address,uint256)",
      [
        ethereum.Value.fromAddress(_staker),
        ethereum.Value.fromUnsignedBigInt(_allowedTokenIndex)
      ]
    );

    return new SLA__getTokenStakeResult(
      result[0].toAddress(),
      result[1].toBigInt()
    );
  }

  try_getTokenStake(
    _staker: Address,
    _allowedTokenIndex: BigInt
  ): ethereum.CallResult<SLA__getTokenStakeResult> {
    let result = super.tryCall(
      "getTokenStake",
      "getTokenStake(address,uint256):(address,uint256)",
      [
        ethereum.Value.fromAddress(_staker),
        ethereum.Value.fromUnsignedBigInt(_allowedTokenIndex)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SLA__getTokenStakeResult(value[0].toAddress(), value[1].toBigInt())
    );
  }

  initialPeriodId(): BigInt {
    let result = super.call(
      "initialPeriodId",
      "initialPeriodId():(uint128)",
      []
    );

    return result[0].toBigInt();
  }

  try_initialPeriodId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "initialPeriodId",
      "initialPeriodId():(uint128)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  ipfsHash(): string {
    let result = super.call("ipfsHash", "ipfsHash():(string)", []);

    return result[0].toString();
  }

  try_ipfsHash(): ethereum.CallResult<string> {
    let result = super.tryCall("ipfsHash", "ipfsHash():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  isAllowedPeriod(_periodId: BigInt): boolean {
    let result = super.call(
      "isAllowedPeriod",
      "isAllowedPeriod(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(_periodId)]
    );

    return result[0].toBoolean();
  }

  try_isAllowedPeriod(_periodId: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isAllowedPeriod",
      "isAllowedPeriod(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(_periodId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isAllowedToken(_tokenAddress: Address): boolean {
    let result = super.call(
      "isAllowedToken",
      "isAllowedToken(address):(bool)",
      [ethereum.Value.fromAddress(_tokenAddress)]
    );

    return result[0].toBoolean();
  }

  try_isAllowedToken(_tokenAddress: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isAllowedToken",
      "isAllowedToken(address):(bool)",
      [ethereum.Value.fromAddress(_tokenAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  leverage(): BigInt {
    let result = super.call("leverage", "leverage():(uint64)", []);

    return result[0].toBigInt();
  }

  try_leverage(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("leverage", "leverage():(uint64)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  messengerAddress(): Address {
    let result = super.call(
      "messengerAddress",
      "messengerAddress():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_messengerAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "messengerAddress",
      "messengerAddress():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  nextVerifiablePeriod(): BigInt {
    let result = super.call(
      "nextVerifiablePeriod",
      "nextVerifiablePeriod():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_nextVerifiablePeriod(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "nextVerifiablePeriod",
      "nextVerifiablePeriod():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  periodSLIs(param0: BigInt): SLA__periodSLIsResult {
    let result = super.call(
      "periodSLIs",
      "periodSLIs(uint256):(uint256,uint256,uint8)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return new SLA__periodSLIsResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toI32()
    );
  }

  try_periodSLIs(param0: BigInt): ethereum.CallResult<SLA__periodSLIsResult> {
    let result = super.tryCall(
      "periodSLIs",
      "periodSLIs(uint256):(uint256,uint256,uint8)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SLA__periodSLIsResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toI32()
      )
    );
  }

  periodType(): i32 {
    let result = super.call("periodType", "periodType():(uint8)", []);

    return result[0].toI32();
  }

  try_periodType(): ethereum.CallResult<i32> {
    let result = super.tryCall("periodType", "periodType():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  providerPool(param0: Address): BigInt {
    let result = super.call("providerPool", "providerPool(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_providerPool(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "providerPool",
      "providerPool(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  registeredStakers(param0: Address): boolean {
    let result = super.call(
      "registeredStakers",
      "registeredStakers(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBoolean();
  }

  try_registeredStakers(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "registeredStakers",
      "registeredStakers(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  slaID(): BigInt {
    let result = super.call("slaID", "slaID():(uint128)", []);

    return result[0].toBigInt();
  }

  try_slaID(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("slaID", "slaID():(uint128)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  stakers(param0: BigInt): Address {
    let result = super.call("stakers", "stakers(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toAddress();
  }

  try_stakers(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall("stakers", "stakers(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  userWithdrawLocked(): boolean {
    let result = super.call(
      "userWithdrawLocked",
      "userWithdrawLocked():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_userWithdrawLocked(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "userWithdrawLocked",
      "userWithdrawLocked():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  usersPool(param0: Address): BigInt {
    let result = super.call("usersPool", "usersPool(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_usersPool(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("usersPool", "usersPool(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  whitelist(param0: Address): boolean {
    let result = super.call("whitelist", "whitelist(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBoolean();
  }

  try_whitelist(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("whitelist", "whitelist(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  whitelistedContract(): boolean {
    let result = super.call(
      "whitelistedContract",
      "whitelistedContract():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_whitelistedContract(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "whitelistedContract",
      "whitelistedContract():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _whitelisted(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }

  get _periodType(): i32 {
    return this._call.inputValues[2].value.toI32();
  }

  get _messengerAddress(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _initialPeriodId(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _finalPeriodId(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get _slaID(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }

  get _ipfsHash(): string {
    return this._call.inputValues[7].value.toString();
  }

  get _extraData(): Array<Bytes> {
    return this._call.inputValues[8].value.toBytesArray();
  }

  get _leverage(): BigInt {
    return this._call.inputValues[9].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AddAllowedTokensCall extends ethereum.Call {
  get inputs(): AddAllowedTokensCall__Inputs {
    return new AddAllowedTokensCall__Inputs(this);
  }

  get outputs(): AddAllowedTokensCall__Outputs {
    return new AddAllowedTokensCall__Outputs(this);
  }
}

export class AddAllowedTokensCall__Inputs {
  _call: AddAllowedTokensCall;

  constructor(call: AddAllowedTokensCall) {
    this._call = call;
  }

  get _tokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class AddAllowedTokensCall__Outputs {
  _call: AddAllowedTokensCall;

  constructor(call: AddAllowedTokensCall) {
    this._call = call;
  }
}

export class AddUsersToWhitelistCall extends ethereum.Call {
  get inputs(): AddUsersToWhitelistCall__Inputs {
    return new AddUsersToWhitelistCall__Inputs(this);
  }

  get outputs(): AddUsersToWhitelistCall__Outputs {
    return new AddUsersToWhitelistCall__Outputs(this);
  }
}

export class AddUsersToWhitelistCall__Inputs {
  _call: AddUsersToWhitelistCall;

  constructor(call: AddUsersToWhitelistCall) {
    this._call = call;
  }

  get _userAddresses(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }
}

export class AddUsersToWhitelistCall__Outputs {
  _call: AddUsersToWhitelistCall;

  constructor(call: AddUsersToWhitelistCall) {
    this._call = call;
  }
}

export class RegisterSLICall extends ethereum.Call {
  get inputs(): RegisterSLICall__Inputs {
    return new RegisterSLICall__Inputs(this);
  }

  get outputs(): RegisterSLICall__Outputs {
    return new RegisterSLICall__Outputs(this);
  }
}

export class RegisterSLICall__Inputs {
  _call: RegisterSLICall;

  constructor(call: RegisterSLICall) {
    this._call = call;
  }

  get _sli(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _periodId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RegisterSLICall__Outputs {
  _call: RegisterSLICall;

  constructor(call: RegisterSLICall) {
    this._call = call;
  }
}

export class RemoveUsersFromWhitelistCall extends ethereum.Call {
  get inputs(): RemoveUsersFromWhitelistCall__Inputs {
    return new RemoveUsersFromWhitelistCall__Inputs(this);
  }

  get outputs(): RemoveUsersFromWhitelistCall__Outputs {
    return new RemoveUsersFromWhitelistCall__Outputs(this);
  }
}

export class RemoveUsersFromWhitelistCall__Inputs {
  _call: RemoveUsersFromWhitelistCall;

  constructor(call: RemoveUsersFromWhitelistCall) {
    this._call = call;
  }

  get _userAddresses(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }
}

export class RemoveUsersFromWhitelistCall__Outputs {
  _call: RemoveUsersFromWhitelistCall;

  constructor(call: RemoveUsersFromWhitelistCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class StakeTokensCall extends ethereum.Call {
  get inputs(): StakeTokensCall__Inputs {
    return new StakeTokensCall__Inputs(this);
  }

  get outputs(): StakeTokensCall__Outputs {
    return new StakeTokensCall__Outputs(this);
  }
}

export class StakeTokensCall__Inputs {
  _call: StakeTokensCall;

  constructor(call: StakeTokensCall) {
    this._call = call;
  }

  get _amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class StakeTokensCall__Outputs {
  _call: StakeTokensCall;

  constructor(call: StakeTokensCall) {
    this._call = call;
  }
}

export class ToggleUserWithdrawLockedCall extends ethereum.Call {
  get inputs(): ToggleUserWithdrawLockedCall__Inputs {
    return new ToggleUserWithdrawLockedCall__Inputs(this);
  }

  get outputs(): ToggleUserWithdrawLockedCall__Outputs {
    return new ToggleUserWithdrawLockedCall__Outputs(this);
  }
}

export class ToggleUserWithdrawLockedCall__Inputs {
  _call: ToggleUserWithdrawLockedCall;

  constructor(call: ToggleUserWithdrawLockedCall) {
    this._call = call;
  }
}

export class ToggleUserWithdrawLockedCall__Outputs {
  _call: ToggleUserWithdrawLockedCall;

  constructor(call: ToggleUserWithdrawLockedCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class WithdrawProviderTokensCall extends ethereum.Call {
  get inputs(): WithdrawProviderTokensCall__Inputs {
    return new WithdrawProviderTokensCall__Inputs(this);
  }

  get outputs(): WithdrawProviderTokensCall__Outputs {
    return new WithdrawProviderTokensCall__Outputs(this);
  }
}

export class WithdrawProviderTokensCall__Inputs {
  _call: WithdrawProviderTokensCall;

  constructor(call: WithdrawProviderTokensCall) {
    this._call = call;
  }

  get _amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _tokenAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class WithdrawProviderTokensCall__Outputs {
  _call: WithdrawProviderTokensCall;

  constructor(call: WithdrawProviderTokensCall) {
    this._call = call;
  }
}

export class WithdrawUserTokensCall extends ethereum.Call {
  get inputs(): WithdrawUserTokensCall__Inputs {
    return new WithdrawUserTokensCall__Inputs(this);
  }

  get outputs(): WithdrawUserTokensCall__Outputs {
    return new WithdrawUserTokensCall__Outputs(this);
  }
}

export class WithdrawUserTokensCall__Inputs {
  _call: WithdrawUserTokensCall;

  constructor(call: WithdrawUserTokensCall) {
    this._call = call;
  }

  get _amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _tokenAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class WithdrawUserTokensCall__Outputs {
  _call: WithdrawUserTokensCall;

  constructor(call: WithdrawUserTokensCall) {
    this._call = call;
  }
}
